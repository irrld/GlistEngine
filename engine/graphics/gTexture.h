/*
* gTexture.h
*
*  Created on: May 10, 2020
*      Author: noyan
*/

#pragma once

#ifndef ENGINE_GRAPHICS_GTEXTURE_H_
#define ENGINE_GRAPHICS_GTEXTURE_H_

#include <string>
#include "gRenderObject.h"
#include "gRect.h"

class gTexture : public gRenderObject {
public:
	enum TextureType : int {
		TEXTURETYPE_DIFFUSE = 0,
		TEXTURETYPE_SPECULAR = 1,
		TEXTURETYPE_NORMAL = 2,
		TEXTURETYPE_HEIGHT = 3,
		TEXTURETYPE_PBR_ALBEDO = 4,
		TEXTURETYPE_PBR_ROUGHNESS = 5,
		TEXTURETYPE_PBR_METALNESS = 6,
		TEXTURETYPE_PBR_NORMAL = 7,
		TEXTURETYPE_PBR_AO = 8
	};

	enum TextureWrap : int {
		TEXTUREWRAP_REPEAT = 0,
		TEXTUREWRAP_CLAMP = 1,
		TEXTUREWRAP_CLAMPTOEDGE = 2,
		TEXTUREWRAP_NEAREST = 3
	};

	enum TextureMagFilter : int {
		TEXTUREMINMAGFILTER_LINEAR = 0,
		TEXTUREMINMAGFILTER_MIPMAPLINEAR = 1,
		TEXTUREMINMAGFILTER_NEAREST = 2,
		TEXTUREMINMAGFILTER_CLAMP = 3
	};

	gTexture();
	gTexture(int w, int h, int format = GL_RGBA, bool isFbo = false);
	virtual ~gTexture();

	virtual unsigned int load(const std::string& fullPath);
	unsigned int loadTexture(const std::string& texturePath);

	/** Loads the mask texture/image to be applied to this instance.
	*
	* It requires full path of the texture/image file.
	*
	* The texture/image might be stored anywhere on the hard disk or other storage
	* devices out of the project folder.
	*
	* @param fullPath The full path to the image or texture file. It should contain the
	* full path of the folder where the image is located, the name of the image
	* and its extension. It is case sensitive.
	*
	* @return Image id number generated by OpenGL.
	*/
	unsigned int loadMask(const std::string& fullPath);

	/** Loads the mask texture/image to be applied to this instance.
	*
	* It requires the name of the texture/image file (ex: "mask.png").
	*
	* The image might be stored anywhere on the hard disk or other storage
	* devices out of the project folder.
	*
	* Project's default folder for masks is ProjectLocation/assets/textures directory.
	*
	* @param maskTexturePath The fullname of the texture/image stored under project's images folder.
	* maskTexturePath should contain texture/image name and its extension. It is case sensitive.
	*
	* @return Image id number generated by OpenGL.
	*/
	unsigned int loadMaskTexture(const std::string& maskTexturePath);

	unsigned int loadData(unsigned char* textureData, int width, int height, int componentNum, bool isMutable = false, bool isStbImage = false);

	void bind() const;
	void bind(int textureSlotNo) const;
	void unbind() const;

	unsigned int getId() const;
	bool isHDR() const;
	unsigned int getInternalFormat() const;
	unsigned int getFormat() const;
	void setType(TextureType textureType);
	TextureType getType() const;
	void setWrapping(int wrapS, int wrapT);
	void setFiltering(int minFilter, int magFilter);
	int getWrapS() const;
	int getWrapT() const;
	int getFilterMin() const;
	int getFilterMag() const;
	const std::string& getTypeName() const;
	const std::string& getFilename() const;
	const std::string& getDir() const;
	const std::string& getFullPath() const;

	int getWidth() const;
	int getHeight() const;
	int getComponentNum() const;

	void draw(int x, int y);
	void draw(int x, int y, int w, int h);
	void draw(int x, int y, int w, int h, float rotate);
	void draw(int x, int y, int w, int h, int pivotx, int pivoty, float rotate);
	void draw(glm::vec2 position, glm::vec2 size, float rotate = 0.0f);
	void draw(glm::vec2 position, glm::vec2 size, glm::vec2 pivot, float rotate = 0.0f);

	void drawSub(int x, int y, int sx, int sy, int sw, int sh);
	void drawSub(int x, int y, int w, int h, int sx, int sy, int sw, int sh);
	void drawSub(int x, int y, int w, int h, int sx, int sy, int sw, int sh, float rotate);
	void drawSub(int x, int y, int w, int h, int sx, int sy, int sw, int sh, int pivotx, int pivoty, float rotate);
	void drawSub(glm::vec2 pos, glm::vec2 size, glm::vec2 subpos, glm::vec2 subsize, float rotate = 0.0f);
	void drawSub(glm::vec2 pos, glm::vec2 size, glm::vec2 subpos, glm::vec2 subsize, glm::vec2 pivot, float rotate = 0.0f);
	void drawSub(const gRect& src, const gRect& dst, float rotate = 0.f);
	void drawSub(const gRect& src, const gRect& dst, int pivotx, int pivoty, float rotate = 0.f);
	void drawSub(const gRect& src, const gRect& dst, glm::vec2 pivot, float rotate = 0.f);

	void setData(unsigned char* textureData, bool isMutable = false, bool isStbImage = false, bool clean = true);

	void setupRenderData();

	void cleanupData();
	void cleanupAll();

	void save(std::string fullpath);
	void saveTexture(std::string fileName);

	unsigned char* getData();

	static const std::string& getTypeName(TextureType textureType);

protected:
	std::string fullpath, directory;
	unsigned int id, internalformat, format;
	TextureType type;
	std::string path;
	int width, height, componentnum;
	unsigned char* data;
	bool ismutable;
	bool isstbimage;
	int wraps, wrapt, filtermin, filtermag;


	bool isMutable();

	std::string getDirName(const std::string& fname);
	std::string getFileName(const std::string& fname);

	bool ishdr;
	float* datahdr;
	void setDataHDR(float* textureData, bool isMutable = false, bool  isStbImage = false, bool clean = true);
	float* getDataHDR();
	bool ismaskloaded;
	gTexture* masktexture;
	bool istextureallocated;

private:

	unsigned int quadVAO, quadVBO;
	glm::mat4 imagematrix;
	void setupRenderData(int sx, int sy, int sw, int sh);
	void beginDraw();
	void endDraw();
	bool isfbo;
	bool isloaded;
	bool issubpart;
	glm::vec2 subpos;
	glm::vec2 subscale;
};

#endif /* ENGINE_GRAPHICS_GTEXTURE_H_ */
